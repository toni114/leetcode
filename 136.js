/**
 * @param {number[]} nums
 * @return {number}
 */
var singleNumber = function(nums) {
  // 这其实是一道数学题
  //
  // 正解之外，其实还有很多其他解法，
  // 并且这些解法里往往都有对应的针对性的特殊优化点，因为“成对”、“两个”本来就是特殊的，
  // 比如 Problem 1 (001.js)；
  // 又比如 Problem 20 (020.js)；
  // 正解本身也是利用了成对出现的对称性。
  //
  // 解法 1、每次 indexOf 数组
  //   相当于两层循环，O(n^2)，没什么价值
  //
  // 解法 2、数组排序，然后查相邻成对出现；
  //   优化：查的时候可以用二分查找，
  //   通过相邻数字的起始位置的奇偶数来判断所在区块；
  //   这类解法不要求目标对象是 number
  //
  // 解法 3、使用哈希表统计计数，统计完之后找到唯一一个只出现过 1 次的
  //   优化：散列 Map 可以只用布尔值（而无需计数），
  //   相当于每次翻转，然后找到第一个奇数次翻转的项；
  //   可以看到，甚至可以优化成，直接退化成集合，
  //   每次交替 add/delete，最后集合里会只剩下那个项本身。
  //   这类解法不要求目标对象是 number
  //
  // 解法 4、依然用哈希表，但是用作集合，
  //   然后 sum(set(nums)) * 2 - sum(nums) 就是想要的那个数字，
  //   思路开始有点巧妙了，但是复杂度跟解法 2 相当，
  //   但是这个解法要求目标对象是 integer，甚至一不小心来个高精度加法的话……
  //
  // 解法 5（正解）、异或 XOR
  //   偶数个相同东西 XOR 在一起会变成 00000000...
  //   而奇数个相同东西搞一起会变回它自己本身，
  //   所以只要所有东西搞一起就 OK 了，最后的结果就是想要的东西……
  //   这个方法其实也不限数字，但是要求可以直接访问对象的存储空间，
  //   又或者值相等的对象能够低成本、唯一地被序列化

  return nums.reduce(((result, value) => result ^ value), 0)
};
